using RestSharp;
using System.Net;

namespace MyFirstTest
{
    // Создаем первый тестовый проект NUnit. Тут вы можете не париться на счет класса program и метода main, а запуск тестов происходит через обозреватель тестов Test Explorer
    public class UnitTest1 // В обозревателе разбиение тестов идет на: имя проекта > namespace > class. Поэтому лучше всего тесты, которые логически связаны между собой и отвечают за один функционал держать в одном классе
    {
        private const string _url = "https://jsonplaceholder.typicode.com"; // Это называется константа. Её нельзя изменить в процессе выполнения программы. Сюда мы укажем ссылку на тестируемый url. Обычно ссылки на сервисы выносят
        //_url = "test"; - ошибка
        // в отдельные конфиги, но мы обойдемся без этого, чтобы не усложнять
        private RestClient _client; // здесь мы с вами пишем поле класса, которое будет содержать объект клиента от фреймворка RestSharp -> RestClient. Именно ему мы будем передавать параметры запроса, а он сам будет отправлять запрос и получать ответ

        [SetUp] // Это называется аннотации, типа параметры методов. Они, в данном случае, указывают когда и сколько раз должен запускаться тот или иной метод. SetUp используется для подготовки тестовых данных или, как в нашем случае, создании 
        // объекта класса RestClient перед каждым нашим тестом. То есть он запускается всегда перед прогоном того или иного теста. Как вы видите класса programm с методом main нет и наши тесты
        // запускаются по другому и тут мы через аннотации сами решаем что и когда в нашем тесте будет запускаться.
        public void Setup() //называем метод Setup без возвращшаемого значения, так как нам нужно просто выполнить действие, просто выполнить метод
        {
            _client = new RestClient(); // При создании клиента RestClient обязательно делать еще метод с аннотацией [TearDown] и вызовом по этому клиенту метода Dispose()
        }

        [TearDown] // Это означает выполнение после основного теста. В нашем случае клиент завершает свою работу через метод Dispose и перестает слать запросы и получать ответы.
                   // Тут мы можем, например, удалять созданные сущности тестовые в процессе или возвращать данные в бд в исходное состояние до выполнения
        public void Teardown()
        {
            _client.Dispose(); 
        }

        [Test] // с помощью аннотации Test у нас обозначаются методы, в воторых происходит какая либо проверка, т.е это наш автотест. Конечная последовательность запусков выглядит так:
        // Выполняется метод с аннотацией [SetUp], потом запускается тест [Test], а затем выполняется [TearDown]. Можем посмотреть в дебаге потом как это работает
        public async Task GetPostsRequest() // напишем наш первый тест, который будет получать Get запрос
        {
            var request = new RestRequest($"{_url}/posts", Method.Get); // создаем перемепнную с запросом, в которой создадим объект класса RestRequest с параметрами, где укажим адрес запроса и метод HTTP
            var response = _client.ExecuteAsync(request); // создадим переменную с результатом ответа сервиса. Здесь мы говорим нашему клиенту RestClient, что нужно отправить запрос с такими то параметрами
                                                          // и тут вы видите слово await. Что это значит А значит то, что когда мы отправляем запрос в какую то внешнюю систему, то мы начинаем ждать от нее ответа и наша программа может либо ждать ответа
                                                          // и продолжить выполняться только ПОСЛЕ получения ответа, либо мы можем отправить запрос, запомнить что он отправлен и дальше выполнять код, а потом дальше где то дождаться ответа и использовать это
                                                          // убрать слово await
                                                          // Простая аналогия: Готовим завтрак
                                                          //Представь, что ты готовишь завтрак:

            //Ставишь чайник(это долгий процесс).
            //Ждешь, пока он закипит(просто стоишь и смотришь на него).
            //Только потом начинаешь делать бутерброд.

            //Это синхронный подход.Ты тратишь время впустую, пока чайник кипятится.

            //А теперь асинхронный подход:
            //Ставишь чайник и идешь делать бутерброд, не дожидаясь, пока он закипит.
            //Когда чайник засвистит, ты возвращаешься к нему и выключаешь.
            //Ты не ждешь, а делаешь полезную работу, пока "долгая" задача выполняется сама по себе.

            //Асинхронность — это способ писать код, который может "ждать, не блокируя" основной поток.

            //Ключевые слова в C#: async и await.
            //async — говорит компилятору: "Эту функцию можно выполнять асинхронно". Это мы пишем как параметр к методу, что говорит о том, что метод у нас асинхронный
            //await — говорит: "На этом месте функция может приостановиться, подождать результат долгой задачи, и продолжить, когда результат будет готов. При этом поток не будет заблокирован.". Это мы используем чаще всего в автотестах
            // так как мы отправляем запрос в сервис и ожидаем его результата. Если результата нет, то и тест падает, так как проверять нечего и что то не так. Без await тест может завершиться, так и не дождавшись ответа

            Console.WriteLine("я делаю что то и это очень важно"); // в дебаге видим, что мы после отправки запроса в сервис идем дальше по выполнению кода
            await response; // тут с помощью await мы говорим, что нам все таки уже нужен результат выполнения запроса и мы подождем его
            var res = response.Result.Content; // тут мы из объекта с результатом забираем результат выполнения операции и берем тело ответа
            Console.WriteLine("Сервис ответил:" + Environment.NewLine + res); // выводим тело ответа в консоль, так ккак это у нас строка обычная

            // С асинхронностью в любом случае придется ждать ответа от сервиса. Вопрос только в том, сделает программа еще чего нибудь полезного за время ожидания или нет. В случае автотестов
            // всегда сразу ждем ответа через await, так как мы не программисты и не пишем сервисы
            // Короче таким образом можно отправлять запросы и получать ответы. Но нужны теперь проверки ожидаемого и фактического результата, так? 
        }

        [Test]
        public async Task CreatePostTest() // создадим новый тест, где будем отправлять post запрос с телом
        {
            var userId = 111; //указываем тут параметры, которые нужно будет передать для удобства и удобной поддержки изменений в случае чего
            var id = 765;
            var title = "Витек привет!";
            var body = "Пойдешь пиво пить?";

            var request = new RestRequest($"{_url}/posts", Method.Post); //создаем реквест, указываем метод Post
            //здесь мы передаем json. Символы перед вставкой строки с джейсоном @$ очень желательны. Благодаря им экранируется что надо и через фигурные скобки можно подставлять будет значения переменных
            var json = @$" {{ 
                   ""userId"": {userId},
                   ""id"": {id},
                   ""title"": ""{title}"",
                   ""body"": ""{body}""
                 }}";
            request.AddBody(json); //добавляем тут наше тело к запросу
            var response = await _client.ExecuteAsync(request); //отправляем запрос и дожидаемся ответа

            Assert.AreEqual(HttpStatusCode.Created, response.StatusCode, $"При создании запроса возникла ошибка:{Environment.NewLine}{response.ErrorMessage}");
            //сравниваем статус код с ожидаемым. Так как это открытое апи не подразумевает реальное создание, то дальше мы проверить ничего не можем. Для этого я создал свой публичный API,где вы можете
            //потренироваться в тестировании и написанию автотестов
        }
    }
}