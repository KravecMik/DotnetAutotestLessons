namespace Lesson2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //Что такое циклы и зачем они нам нужны? 
            //Циклы позволяют выполнять один и тот же блок кода несколько раз или перебирать значения в массивах
            //Например, чтобы не писать так
            var num = 1;
            num = num + 1;
            num = num + 1;
            num = num + 1;
            num = num + 1;
            num = num + 1;
            num = num + 1;
            num = num + 1;

            //Можно запихать это дело в цикл и указывая один какой то параметр или условие остановки гонять его до одури. Существует несколько видов циклов в шарпах
            //Но прежде чем к ним перейти, нужно еще одну штуку понять. Инкремент и декремент называется

            //чтобы такой стрем не писать
            num = num + 1;

            //можно немного сократить, используя как раз таки Инкремент. Че это такое? Да просто пишешь два плюса после названия переменной и она увеличивается на единичку
            num++; //вот это равносильно num = num + 1;

            //А так как вы у меня догадливые, то поймете, что декремент делает наоборот и уменьшает на единичку число
            num--;

            //var str = num.ToString();
            //str++; //так вот делать нельзя, тк к строке нельзя прибавлять числа как в математике.

            //ДОМАШНЕЕ ЗАДАНИЕ: попробуй использовать инкремент и декремент на типах аля bool, decimal, double и посмотреть что получится

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //Итак, самый базовый и самый ресурсоемкий по производительности цикл - это цикл for
            // Синтаксис: for(инициализация; условие; итерация)
            // Инициализация - это когда мы объявляем переменную, которая будет использоваться в данном цикле и с помощью инкремента или дикремента в конце увеличиваться или уменьшаться
            // как раз в конце где итерация это можно увидеть 
            // условия собственно нужно для того, чтобы ограничить выполнение цикла до какого то момента или он просто будет работать БЕСКОНЕЧНО буквально
            // в данном примере цикл будет работать, пока переменная i не станет равна 5. 0 - 1 - 2 - 3 - 4 - 5, но пятерка не будет учитываться, так как мы сначала проверяем условие
            // а затем только, если оно не выполнилось, переходим к телу цикла. К стати, тело, как видите, ограничено фигурными скобками { } - это обязательный синктаксис
            // Давайте подебажим и посмотрим как цикл работает
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine($"Итерация номер: {i}");
            }

            // Как я сказал ранее, переменная i существует ТОЛЬКО внутри цикла, т.е когда мы из цикла выходим, она удаляется из памяти и вне его получаем ошибку, мол такой переменной я не знаю
            //Console.WriteLine(i);

            //маленький прикол. Что будет, если мы сделаем цикл фор с таким условием?
            //for (int i = 6; i > 5; i++)
            //{
            //    Console.WriteLine($"Итерация номер: {i}");
            //}

            //Этот цикл удобно использовать как раз таки, когда нужно определенное количество раз выполнить одно и то же, например, создать какое то колличество тестовых данных для автотестов
            //Можно генерировать сущности типа там товара в магазине какого то или пользователя, отправлять это в бэкенд и потом проверять на UI отображение (потом будем с вами это делать)
            //Ну а пока условно я покажу это так
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine($"Создай тестовые данные по братски пж");
            }

            //Так же можно с помощью этого цикла проходить по массивам данных. Из прошлого урока вы видели, что можно по индексу внутри квадратных скорочек получать значение массива
            int[] arr = [1, 2, 3, 4, 5];
            //Так как вывести в консоль все значения ?
            //Можно так:

            Console.WriteLine(arr[0]); //Помним, что отсчет с 0 начинается, а не с 1
            Console.WriteLine(arr[1]);
            Console.WriteLine(arr[2]);
            Console.WriteLine(arr[3]);
            Console.WriteLine(arr[4]);

            //Но это херня неудобная, некрасивая и громоздкая
            //Вводим слово for и нажимаем таб и вижла сама подсказывает и вставляет нужную структуру цикла. Нужно только табать. Указываем условие равное количеству элементов в массиве и вуаля, работает
            //Но у масссивов, как и у всех типов данных, есть свои приколы взаимодействия с ними. И с помощью связки название переменной + точка + слова Length получить количество элементов в массиве
            var quantity = arr.Length;

            for (int i = 0; i < quantity; i++)
            {
                Console.WriteLine(arr[i]);
            }

            //Если выйти за рамки элементов и обратиться к значению, которого нет - то будет ошибка IndexOutOfRangeException
            //for (int i = 0; i < 6; i++)
            //{
            //    Console.WriteLine(arr[i]);
            //}

            //Вообще массивы не особо поддатливы в плане добавления новой информации туда, то есть если ты его инициировал с каким то наборов элементов, то новые в него добавить не получится
            //Только если костылить, а это ред флаг.

            //Этот цикл чаще всего я использую в UI автотестах, где нужно проверить например элементы в таблице, так как к ним можно обращаться по индексам. Первый элемент, второй и так далее
            //И эта цифорка i подставляется в UI путь с названием xpath. Потом будем разбирать, когда UI затронем. 

            //ДОМАШНЕЕ ЗАДАНИЕ: побалуйся с циклом фор. Повыводи всякие значения в нем в консоль, попробуй бахнуть 999999 выводов. Создай массивы со стрингами и их покрути

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //Второй базовый цикл - это цикл while 
            //Выполняется до тех пор, пока условие истинно
            //В примере мы видим все те же скобочки фигурные, но счетчик уже не идет обязательным условием. Тут он более для наглядности. Но и плюс так как переменная вне цикла, то ее потом можно использовать
            //Например вывести за сколько итераций ты успешно или не успешно пытался выполнить действие. Например, на UI тыкнуть на элемент. Чтобы ошибка была осмысленнее
            int counter = 0;
            while (counter < 3)
            {
                Console.WriteLine($"Счетчик: {counter}");
                counter++;
            }

            //while можно представить так while (true), т.е пока какое то условие истинно, до тех пор выполняем. Если условие изначально ложное, то он ничего не сделает
            //Это понимает компилятор и поэтому такой код погасшим показывает, те цикл не запустится ни разу
            while (false)
            {
                Console.WriteLine($"Я не запущусь никогда(((");
            }

            //А вот есть такой прикол, если туда поставить true. В таком случае мы уйдем в бесконечность. Поэтому всегда нужно за этим следить и делать так, чтобы из цикла можно было выйти
            //while (true)
            //{ 
            //    Console.WriteLine($"Ну что народ, погнали на!!!!");
            //}

            //Пример:
            //bool isTrue = true;

            //while (isTrue)
            //{
            //    Console.WriteLine($"Счетчик: {counter}");
            //    isTrue = false;
            //}

            //Тут мы объявили переменную с правдивой логикой, чтобы цикл выполнился и внутри цикла поменяли значение этой переменной на false. Благодаря этому у нас второй раз цикл уже не выполняется
            //Такой цикл в автотестах я использую для "умных" ожиданий. Те я жду элементы на странице какое то время и пытаюсь до них достучаться, а не сразу упасть. Поэтому нужен цикл

            //ДОМАШНЕЕ ЗАДАНИЕ: покрути цикл вайл с различными условиями и сравнениями типа > < == и попробуй внутри цикла for сделать как то и цикл while и посмотри что происходит в дебаге

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //Поговорим про операторы сравнения. Если условие оператора корректное, то получаем true. В ином случае false. А что, если нам нужно сравнить то, что НЕ равно чему либо? типа обратная логика
            //Типа что на странице НЕ отображается что то. В таком случае мы добавляем восклицательный знак (!) что означает - НЕ ТРУ или НЕ ФОЛС

            //В таком случае наш цикл while, например, выполняется в том случае, если у него в скобках false. Из прошлого примера с восклицательным знаком мы не зайдем в цикл, тк он теперь
            //работает только когда там значение false
            //bool isTrue = true;

            //while (!isTrue)
            //{
            //    Console.WriteLine($"Запущусь, если дашь мне false дружище");
            //    isTrue = false;
            //}

            ////Вот все возможные примеры сравнения в цикле while
            //var x = 5;
            //var y = 10;

            //while (x == y) //Равно ли 5 десяти? Нет. Значит будет false и цикл не запустится.
            //{
            //    Console.WriteLine($"Я не запущусь :р");
            //}

            //while (x != y) //А если вместо одного равно поставить восклицательный знак, то мы проверяем наоборот, что переменные НЕ равны. В таком случае будет true и цикл запустится и так будет до тех пор, пока они не станут равны

            //{
            //    Console.WriteLine($"Стартуем!");
            //}

            //while (x < y) // Больше ли 10 чем 5? Да. Значит цикл запустится, но уйдет в бесконечность. ДОМАШНЕЕ ЗАДАНИЕ: Придумай как можно это исправить одной строчкой
            //{
            //    Console.WriteLine($"Стартуем!");
            //}

            //while (x !< y) // Если тут поставить перед знаком сравнения восклицательный знак, то наоборот ты проверяешь, что x НЕ меньше y. Обратная логика, фигли. Это только нужно запомнить и попрактиковаться
            //{
            //    Console.WriteLine($"Я не запущусь :р");
            //}

            //Как еще ставнивать можно? >= (это больше или равно), <= (меньше или равно). Если восклицашку добавить, то будет НЕ больше или равно и НЕ меньше или равно. Короче НЕ подставляете и все

            //ДОМАШНЕЕ ЗАДАНИЕ: попробуй, зная новые способы сравнения, поделать бесконечные циклы когда условие всегда будет тру или наоборот фолс

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //Цикл do-while. Это то же самое, что и прошлый цикл, только он всегда сначала запускается, а потом уже какие то условия проверяет. Редко очень используется
            //var number = 5;
            //do
            //{
            //    number ++;
            //}
            //while (number <= 10);

            //Например, если без ! знака передать false в while, то один то раз он все таки выполнится
            do
            {
                Console.WriteLine("Я живооооооооой");
            }
            while (false);

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //Понимаю, что тема сложная и с первого раза можно не въехать, но с дебагом, в целом, можно представить как оно работает. Поэтому обязательно потыкайте циклы - это база базная
            //По этой теме вообще целые книги пишут люди, потому что они влияют на производительность программ и плохой цикл может сделать ваше приложение ультрамедленным и лагучим

            //И напоследок самый крутой и используемый цикл это - Цикл foreach, который переводится как for для each каждого. Используем его для прохождения по элементам коллекций, списков и всего, чего больше одного
            //Тут мы можем проверять на UI список элементов в таблице, например или в беке на GET запросе все элементы полученного списка. Он очень быстрый и если можно использовать его, то лучше ничего другого не брать

            //Пишется он так. var fruit - это каждый элемент, который берется по порядку. in fruits это откуда берется список. Запустить и посмотреть что происходит внутри. Менять элементы внутри списка или массива нельзя

            //string[] fruits = { "яблоко", "банан", "апельсин" };
            //foreach (var fruit in fruits)
            //{
            //    Console.WriteLine(fruit);
            //} 

            //Менять элементы внутри списка или массива нельзя, так как они выгружены в память отдельно и доступны только для чтения (чтобы хакеры взломать не могли)

            //string[] fruits = { "яблоко", "банан", "апельсин" };
            //foreach (var fruit in fruits)
            //{
            //    fruit = "рапрва";
            //    Console.WriteLine(fruit);
            //}

            //ДОМАШНЕЕ ЗАДАНИЕ: создай массив с текстом или с цифрами и попробуй прогнать его в foreach под дебаггером

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            // Давайте теперь эту тему всю с циклами полирнём и научимся делать проверки внутри цикла
            // Предлагаю сравнить два списка между собой, типа ожидаемый результат и фактический. Тут удобнее всего использовать цикл for, так как мы перебираем одновременно два списка и сравниваем их

            //string[] expectedFruits = { "яблоко", "банан", "апельсин" }; //Тут мы указываем массив ожидаемого результата
            //string[] actualFruits = { "яблоко", "банан", "енот" }; //А тут указываем то, что нам пришло, например, из сервиса

            //for (int i = 0; i < expectedFruits.Length; i++)
            //{
            //    var isEqual = expectedFruits[i] == actualFruits[i]; 
            //    if (!isEqual) //тут появляется одна из базовых вещей всех проверок. Это блок if. По умолчанию, если в этом блоке true, то тогда он выполняется. Но мы знаем, что с помощью ! можно это инвертировать и тогда блок выполнится с помощью false
            //    {
            //        Console.WriteLine("Ожидали значение: " + expectedFruits[i] + ", а получили: " + actualFruits[i]);
            //    }
            //}

            //Что будет, если мы получим меньше элементов? То в таком случае когда наш индекс выйдет за пределы количества элементов, то получим эксепшн и код экстренно завершится, тк мы пытаемся получить инфу из области памяти, в которой ничего нет
            string[] expectedFruits = { "яблоко", "банан", "апельсин" };
            string[] actualFruits = { "яблоко", "банан" };

            for (int i = 0; i < expectedFruits.Length; i++)
            {
                var isEqual = expectedFruits[i] == actualFruits[i];
                if (!isEqual)
                {
                    Console.WriteLine($"Ожидали значение: {expectedFruits[i]}, а получили: {actualFruits[i]}");
                }
            }

            //В таком случае, для подстраховки, лучше сначала сравнивать количество элементов в массивах, а только потом если все ок - проходить в цикле
            //string[] expectedFruits = { "яблоко", "банан", "апельсин" };
            //string[] actualFruits = { "яблоко", "банан" };

            ////Давайте сделаем это с базовой проверкой, которую в автотестах используют с названием Assert

            //var isLengthEqual = expectedFruits.Length == actualFruits.Length;
            //Assert.That(isLengthEqual, "Количество элементов отличается"); //че тут выходит, сначала указываем условие, которое вернет тру или фолс, а потом через запятую строку с ошибкой пишем, если будет фолс
            ////Попробовать перед isLengthEqual в That поставить восклицательный и убедиться, что в таком случае код идет дальше

            //for (int i = 0; i < expectedFruits.Length; i++)
            //{
            //    var isFruitEqual = expectedFruits[i] == actualFruits[i]; //Сравниваем по одному фрукту из каждого массива. Если фрукты равны, то будет тру и записываем это в переменную isFruitEqual
            //    if (!isFruitEqual) //Тут поставили (!), чтобы если фруктики НЕ равны, то тогда проваливаемся внутрь скобок фигурных
            //    {
            //        Assert.Fail($"Ожидали значение: {expectedFruits[i]}, а получили: {actualFruits[i]}"); //А тута мы просто падаем дева4ки с заданным текстом. Чтобы информативно было. Выведется в текст ошибки
            //        //доллар перед скобкой позволяет не городить связки между строками через сложение их, а внутри одной строки подставлять нужные значения. Писец как удобно и красиво.
            //        //то,что нужно подставить из переменных просто фигурными скобками обрамляешь
            //    }
            //}

            //ДОМАШНЕЕ ЗАДАНИЕ: попиши свои мини автотестики и попробуй сделать кейсы, где они проходят, а где падают. Поиграйся с инверсией логики (!)

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //Напоследок познакомимся с таким словом, как break, то есть прекращение по англосаксонски

            //Допустим, нам из массива нужен только какой то элемент посередине. Тогда че, все равно остальные элементы перебирать зазря? Тратить драгоценное время прогонов автотестов на фигню
            //Возьмем такой массив с названиями прекрасных тачек. И нам нужна только одна машина мечты - "Жили". Давайте так, если мы найдем в массиве жили, то тогда не будем остальные смотреть. А смысл?
            //Машина мечты же найдена
            string[] words = { "Чанган", "Жили", "Омода", "Лада", "Мерседес", "БМВ", "Хонда", "Хавал?" };

            //Для этого можно использовать цикл foreach, ведь массив у нас один и никаких индексов нам не надо. Нужен тупо перебор всех элементов подряд. Пишем foreach и тыкаем на ТАБ
            foreach (var word in words) //Тут все по классике. В массиве words проходим по каждому word внутри
            {
                if (word == "Жили") //Тут задаем выражение, которое если верно, то попадаем в огороженный блок кода
                {
                    Console.WriteLine($"- Ало братан, я купил себе новенький {word}, не могу сейчас говорить");
                    Console.WriteLine($"- Так это ты мне позвонил");
                    Console.WriteLine($"- Все, пока!"); //Тут в целом ничего необычного не происходит. Мы что то делаем
                    break; //А вот это слово прекращает выполнение цикла, типа хорош работать, пора на break. После этого слово писать код бессмысленно, тк все равно будет проигнорирован
                    Console.WriteLine($"Онеме"); //Тут в целом ничего необычного не происходит. Мы что то делаем
                }
            }
            Console.WriteLine($"Вот так как то и живем");
            //Есть еще одно слово continue, которое наоборот продолжает выполнение цикла, но вот практически я его оооочень редко использовал. Только когда в кафка искал нужное сообщение

            //ДОМАШНЕЕ ЗАДАНИЕ: Попробуй пристроить слово break в остальных циклах.

            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        }
    }
}